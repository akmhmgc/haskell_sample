# はじめの第一歩

## リスト

`[1,2,3]`は`1:2:3[]`の構文糖衣（簡略化された構文）

## 遅延評価

実際に無限のリストが作成される

```sh
[1..]
```

必要なタイミングまでリストは作られないので、結局3つのリストしか生成されない

```hs
take 3 [1..]
[1,2,3]
```

## リスト内包表記

```hs
[ x*2 | x <- [1..10]]
-- [2,4,6,8,10,12,14,16,18,20]
```

```hs
[ (a,b,c) | c <- [1 .. 10], a <- [1 .. c], b <- [1 .. a], a^2 + b^2 == c^2]
--  [(4,3,5),(8,6,10)]
```

# 型を信じろ

## 型の宣言

引数と返り値を区別せずに`->`で指定

```hs
addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
```

## 型クラス

オブジェクト指向のクラスと同じ意味ではない

```hs
:t (==)
-- (==) :: Eq a => a -> a -> Bool
```

- 第一引数と第二引数に同じ型をとってBool型を返す
- 引数はEqの型クラスのインスタンスである必要がある

## 型クラスと型

- ある型は複数の型クラスのインスタンスとなりうる
  - CharもIntもEq型クラスのインスタンス
- ある型クラスのインスタンスであるためには他の型クラスのインスタンスであることが必須である場合がある
  - Ord型クラスのインスタンスになるためにはEqクラスのインスタンスであることが必須
